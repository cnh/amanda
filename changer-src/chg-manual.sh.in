#!/bin/sh 
#
# Exit Status:
# 0 Alles Ok
# 1 Illegal Request
# 2 Fatal Error
#

# try to hit all the possibilities here
prefix=@prefix@
exec_prefix=@exec_prefix@
libexecdir=@libexecdir@

PATH=$libexecdir:/usr/bin:/bin:/usr/sbin:/sbin:/usr/ucb
export PATH

USE_VERSION_SUFFIXES="@USE_VERSION_SUFFIXES@"
if test "$USE_VERSION_SUFFIXES" = "yes"; then
	SUF="-@VERSION@"
else
	SUF=
fi

myname=$0
DEBUG_DIR=@DEBUG_DIR@
EGREP=@EGREP@
MT=@MT@
MTF=@MT_FILE_FLAG@
DD=@DD@
MAILER=@MAILER@
ONLINEREGEX="ONLINE|READY|sense[_ ]key[(]0x0[)]|sense key error = 0|^er=0$"
REPORTTO=`getconf$SUF mailto`
tape=`getconf$SUF tapedev`
ORG=`getconf$SUF ORG`

changerfile=`getconf$SUF changerfile`

cleanfile=$changerfile-clean
accessfile=$changerfile-access
slotfile=$changerfile-slot
[ ! -f $cleanfile ] && echo 0 > $cleanfile
[ ! -f $accessfile ] && echo 0 > $accessfile
[ ! -f $slotfile ] && echo 0 > $slotfile
cleancount=`cat $cleanfile`
accesscount=`cat $accessfile`
slot=`cat $slotfile`

# this starts at 1 !!!
lastslot=99
#

dbglog=$DEBUG_DIR/changer.debug

request() {
	echo "insert tape into slot $1 and press return" >/dev/tty
	read ANSWER </dev/tty
}

###
# If $changerfile exists, source it into this script.  One reason is to
# override the request() function above which gets called to request
# that a tape be mounted.  Here is an alternate versions of request()
# that does things more asynchronous:
#
#  request() {
#	# Send E-mail about the mount request and wait for the drive
#	# to go ready by checking the status once a minute.  Repeat
#       # the E-mail once an hour in case it gets lost.
#	timeout=0
#	while true;do
#	    if [ $timeout -le 0 ]; then
#		echo "insert Amanda tape into slot $1 ($tape)" \
#		  | $MAILER -s "$ORG AMANDA TAPE MOUNT REQUEST FOR SLOT $1" \
#		          $REPORTTO
#		timeout=`expr 60 \* 60`
#	    fi
#	    echo "     -> rewind $tape" >> $dbglog
#	    $MT $MTF $tape rewind >> $dbglog 2>&1
#	    echo "     -> status $tape" >> $dbglog
#	    used=`$MT $MTF $tape status 2>&1 | tee -a $dbglog | $EGREP "$ONLINEREGEX"`
#	    echo "     -> loaded <$used>" >> $dbglog
#	    if [ ! -z "$used" ];then
#		break
#	    fi
#	    sleep 60
#	    timeout=`expr $timeout - 60`
#	done
#  }
#
# Instead of sending mail, you might write the message to /dev/console
# or use "logger" to send it via syslog, etc.
###

if [ -f $changerfile ]; then
	. $changerfile
fi

#

eject() { 
	echo "     -> rewind $tape" >> $dbglog
	$MT $MTF $tape rewind >> $dbglog 2>&1
	echo "     -> status $tape" >> $dbglog
	used=`$MT $MTF $tape status 2>&1 | tee -a $dbglog | $EGREP "$ONLINEREGEX"`
	echo "     -> loaded <$used>" >> $dbglog
	if [ ! -z "$used" ];then
		echo "     -> offline $tape" >> $dbglog
		$MT $MTF $tape offline >> $dbglog 2>&1
		echo 0 > $slotfile
		answer="$slot $tape"
		code=0
	else
		answer="0 Drive was not loaded"
		code=1
	fi
	echo "Exit -> $answer" >> $dbglog
	echo "$answer"
	exit $code
}

#

reset() {
	echo "     -> rewind $tape" >> $dbglog
	$MT $MTF $tape rewind >> $dbglog 2>&1
	echo "     -> status $tape" >> $dbglog
	used=`$MT $MTF $tape status 2>&1 | tee -a $dbglog | $EGREP "$ONLINEREGEX"`
	echo "     -> loaded <$used>" >> $dbglog
	if [ ! -z "$used" ];then
		answer="$slot $tape"
	else
		answer="0 $tape"
	fi
	echo "Exit -> $answer" >> $dbglog
	echo "$answer"
	exit 0
}

# load #

loadslot() {
	echo "     -> rewind $tape" >> $dbglog
	$MT $MTF $tape rewind >> $dbglog 2>&1
	echo "     -> status $tape" >> $dbglog
	used=`$MT $MTF $tape status 2>&1 | tee -a $dbglog | $EGREP "$ONLINEREGEX"`
	echo "     -> loaded <$used>" >> $dbglog
	whichslot=$1
	case $whichslot in
	current)
		load=$slot
		;;
	next|advance)
		load=`expr $slot + 1`
		;;
	prev)
		load=`expr $used - 1`
		[ $load eq 0 ] && load=1
		;;
	first)
		load=1
		;;
	last)
		# for compatibility only
		load=1
		;;
	[0-9]*)
		load=$1
		;;
	*)
		answer="0 illegal request"
		echo "Exit -> $answer" >> $dbglog
		echo "$answer"
		exit 1
		;;
	esac
	#
	if [ ! -z "$used" -a $load = $slot ];then
		# already loaded
		answer="$slot $tape"
		echo "Exit -> $answer" >> $dbglog
		echo "$answer"
		exit 0
	fi

	# if [ $load = $ecleanslot ]; then
	# expr $cleancount + 1 > $cleanfile
	# echo 0 > $accessfile
	# else
	expr $accesscount + 1 > $accessfile
	# if [ $accesscount -gt 9 ]; then
	# $myname -slot $cleanslot >/dev/null
	# used=0
	# fi
	# fi	

	#
	if [ ! -z "$used" ]; then
		echo "     -> offline $tape" >> $dbglog
		$MT $MTF $tape offline >> $dbglog 2>&1
		used=""
	fi
	if [ $whichslot = advance ]; then
		tape=/dev/null
	else
		echo "     -> load   $load" >> $dbglog
		while [ -z "$used" ]; do
			request $load
			echo "     -> rewind $tape" >> $dbglog
			$MT $MTF $tape rewind >> $dbglog 2>&1
			echo "     -> status $tape" >> $dbglog
			used=`$MT $MTF $tape status 2>&1 | tee -a $dbglog | $EGREP "$ONLINEREGEX"`
			echo "     -> loaded <$used>" >> $dbglog
		done
		$DD if=$tape count=1 >> $dbglog 2>&1
	fi
	echo $load > $slotfile
	answer="$load $tape"
	echo "Exit -> $answer" >> $dbglog
	echo "$answer"
	exit 0
}

#

info() {
	echo "     -> rewind $tape" >> $dbglog
	$MT $MTF $tape rewind >> $dbglog 2>&1
	echo "     -> status $tape" >> $dbglog
	used=`$MT $MTF $tape status 2>&1 | tee -a $dbglog | $EGREP "$ONLINEREGEX"`
	echo "     -> loaded <$used>" >> $dbglog
	if [ -z "$used" ];then
		answer="0 $lastslot 1"
	else
		answer="$slot $lastslot 1"
	fi
	echo "Exit -> $answer" >> $dbglog
	echo "$answer"
	exit 0
}

#
# main part
#

echo "Args -> $*" >> $dbglog
while [ $# -ge 1 ];do
	case $1 in
	-slot)
		shift
		loadslot $*
		;;
	-info)
		shift
		info
		;;
	-reset)
		shift
		reset
		;;
	-eject)
		shift
		eject
		;;
	*)
		echo "Unknown option $1"
		exit 2
		;;
	esac
done

exit 0
